import sqlite3
import logging
import datetime
import asyncio
import os
import requests
import io # Added for BytesIO
import base64 # Added for base64 decoding

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ConversationHandler,
    MessageHandler,
    filters,
    ContextTypes,
)
from telegram.constants import ParseMode

# --- Configuration Section ---
TELEGRAM_BOT_TOKEN = "YOUR_TELEGRAM_BOT_TOKEN" # ржЖржкржирж╛рж░ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржмржЯ ржЯрзЛржХрзЗржи ржжрж┐ржи
SUPER_ADMIN_ID = 123456789 # ржЖржкржирж╛рж░ рж╕рзБржкрж╛рж░ ржЕрзНржпрж╛ржбржорж┐ржи ID ржжрж┐ржи
SUB_ADMIN_IDS = [] # ржЕржирзНржпрж╛ржирзНржп рж╕рж╛ржм ржЕрзНржпрж╛ржбржорж┐ржи ID ржЧрзБрж▓рзЛ рж▓рж┐рж╕рзНржЯрзЗ ржпрзЛржЧ ржХрж░рзБржи
ALL_ADMIN_IDS = [SUPER_ADMIN_ID] + SUB_ADMIN_IDS
ITEMS_PER_PAGE = 5
WHATSAPP_API_URL = "http://localhost:3000"  # WhatsApp API рж╕рж╛рж░рзНржнрж╛рж░рзЗрж░ ржарж┐ржХрж╛ржирж╛

# ржкржпрж╝рзЗржирзНржЯ рж╕рж┐рж╕рзНржЯрзЗржо
POINTS_PER_LOGIN = 10
POINTS_PER_REFERRAL = 20
POINTS_PER_DAILY_LOGIN = 5
POINTS_STREAK_BONUS = 50 # Not used in current code, but can be implemented
POINTS_TO_BDT_RATE = 10
MIN_WITHDRAWAL_BDT = 100

# Conversation states
PHONE_NUMBER, WAIT_FOR_QR_CONFIRMATION, WITHDRAW_AMOUNT, WITHDRAW_NUMBER, BROADCAST_MESSAGE, ADMIN_SESSION_ACTION = range(6)

# Logging setup
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Database Setup ---
def setup_database():
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY, 
        username TEXT, 
        points INTEGER DEFAULT 0, 
        referral_code TEXT,
        referred_by INTEGER, 
        last_login DATE, 
        login_streak INTEGER DEFAULT 0,
        successful_sessions INTEGER DEFAULT 0, 
        failed_sessions INTEGER DEFAULT 0
    )""")
    # Note: 'session_data' will now store a placeholder, as baileys manages files.
    # 'two_fa_pass' is removed as it's not applicable with baileys in this context.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
        session_id INTEGER PRIMARY KEY AUTOINCREMENT, 
        user_id INTEGER, 
        phone_number TEXT NOT NULL UNIQUE, -- Phone number should be unique per session
        session_data TEXT DEFAULT 'Baileys Managed', -- Placeholder
        status TEXT DEFAULT 'active', 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (user_id)
    )""")
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS withdrawals (
        request_id INTEGER PRIMARY KEY AUTOINCREMENT, 
        user_id INTEGER, 
        amount_bdt REAL,
        points_used INTEGER, 
        payment_number TEXT, 
        status TEXT DEFAULT 'pending',
        requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 
        FOREIGN KEY (user_id) REFERENCES users (user_id)
    )""")
    conn.commit()
    conn.close()

# --- WhatsApp API Functions ---
async def initiate_whatsapp_login(phone_number: str) -> (str, str):
    """WhatsApp рж▓ржЧржЗржи рж╢рзБрж░рзБ ржХрж░рзЗ ржПржмржВ QR ржХрзЛржб ржЗржорзЗржЬрзЗрж░ URL ржмрж╛ Data URL рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ"""
    try:
        response = requests.post(
            f"{WHATSAPP_API_URL}/sessions", 
            json={"phone": phone_number}
        )
        if response.status_code == 200:
            data = response.json()
            qr_url = data.get("qr_url")
            status = data.get("status") # 'authenticated' if already logged in
            return qr_url, status
        elif response.status_code == 409: # Session already exists
            logger.info(f"Session for {phone_number} already exists.")
            return None, "exists"
        logger.error(f"API error: {response.status_code} - {response.text}")
        return None, "error"
    except Exception as e:
        logger.error(f"Error initiating WhatsApp login: {e}")
        return None, "error"

async def check_whatsapp_login_status(phone_number: str) -> str:
    """WhatsApp рж▓ржЧржЗржи рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕ ржЪрзЗржХ ржХрж░рзЗ ('authenticated', 'pending_qr', 'not_found')"""
    try:
        response = requests.get(
            f"{WHATSAPP_API_URL}/sessions/{phone_number}/status"
        )
        if response.status_code == 200:
            data = response.json()
            return data.get("status")
        elif response.status_code == 404:
            return "not_found"
        logger.error(f"API status check error: {response.status_code} - {response.text}")
        return "error"
    except Exception as e:
        logger.error(f"Error checking login status: {e}")
        return "error"

async def terminate_whatsapp_session(phone_number: str) -> bool:
    """WhatsApp рж╕рзЗрж╢ржи terminate ржХрж░рзЗ"""
    try:
        response = requests.delete(
            f"{WHATSAPP_API_URL}/sessions/{phone_number}"
        )
        if response.status_code == 200:
            return True
        logger.error(f"API session termination error: {response.status_code} - {response.text}")
        return False
    except Exception as e:
        logger.error(f"Error terminating WhatsApp session: {e}")
        return False

# --- UI Helper Functions ---
def get_main_keyboard(user_id: int) -> ReplyKeyboardMarkup:
    if user_id in ALL_ADMIN_IDS:
        keyboard = [
            ["ЁЯСБя╕П ржЗржЙржЬрж╛рж░ рж▓рж┐рж╕рзНржЯ", "ЁЯз╛ ржЙржЗржержбрзНрж░ рж░рж┐ржХрзБрзЯрзЗрж╕рзНржЯ"],
            ["ЁЯФБ рж╕рзЗрж╢ржи ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ", "ЁЯФФ ржмрзНрж░ржбржХрж╛рж╕рзНржЯ"],
        ]
    else:
        keyboard = [
            ["тЦ╢я╕П WhatsApp рж▓ржЧржЗржи", "ЁЯУК ржЖржорж╛рж░ ржПржХрж╛ржЙржирзНржЯ"],
            ["ЁЯТ░ ржЙржЗржержбрзНрж░", "ЁЯОБ рж░рзЗржлрж╛рж░ ржХрзЛржб"],
            ["тЬЕ Active Sessions"],
        ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)

# --- Start Command & Main Handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id
    
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    db_user = cursor.fetchone()
    
    if not db_user:
        referral_code = f"ref_{user_id}"
        cursor.execute(
            "INSERT INTO users (user_id, username, referral_code, last_login, login_streak, points) VALUES (?, ?, ?, ?, ?, ?)",
            (user_id, user.username or user.first_name, referral_code, datetime.date.today(), 1, POINTS_PER_DAILY_LOGIN)
        )
        await update.message.reply_text(f"рж╕рзНржмрж╛ржЧрждржо! ржЖржкржирж┐ ржкрзНрж░ржержоржмрж╛рж░ рж▓ржЧржЗржи ржХрж░рж╛рж░ ржЬржирзНржп {POINTS_PER_DAILY_LOGIN} ржкрзЯрзЗржирзНржЯ ржкрзЗрзЯрзЗржЫрзЗржиред")
    else:
        today = datetime.date.today()
        # Ensure last_login is handled correctly, even if it's None or invalid
        last_login_str = db_user[5] if db_user and len(db_user) > 5 and db_user[5] else '1970-01-01'
        try:
            last_login = datetime.datetime.strptime(last_login_str, '%Y-%m-%d').date()
        except ValueError:
            last_login = datetime.date(1970, 1, 1) # Fallback to a very old date

        if last_login < today:
            cursor.execute("UPDATE users SET points = points + ?, last_login = ? WHERE user_id = ?", 
                          (POINTS_PER_DAILY_LOGIN, today, user_id))
            await context.bot.send_message(chat_id=user_id, text=f"ржкрзБржирж░рж╛рзЯ рж╕рзНржмрж╛ржЧрждржо! ржЖржЬржХрзЗрж░ ржбрзЗржЗрж▓рж┐ рж▓ржЧржЗржи ржмрзЛржирж╛рж╕: {POINTS_PER_DAILY_LOGIN} ржкрзЯрзЗржирзНржЯред")

    conn.commit()
    conn.close()

    reply_markup = get_main_keyboard(user_id)
    await update.message.reply_text("ЁЯСЛ ржЖржкржирж╛ржХрзЗ рж╕рзНржмрж╛ржЧрждржо! ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржПржХржЯрж┐ ржЕржкрж╢ржи ржмрзЗржЫрзЗ ржирж┐ржи:", reply_markup=reply_markup)
    return ConversationHandler.END

async def main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text
    user_id = update.effective_user.id
    
    if text == "тЦ╢я╕П WhatsApp рж▓ржЧржЗржи":
        await update.message.reply_text("ЁЯУЮ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржкржирж╛рж░ WhatsApp ржиржорзНржмрж░ржЯрж┐ ржХрж╛ржирзНржЯрзНрж░рж┐ ржХрзЛржбрж╕рж╣ ржжрж┐ржи (ржпрзЗржоржи: +8801712345678):")
        return PHONE_NUMBER
    elif text == "ЁЯУК ржЖржорж╛рж░ ржПржХрж╛ржЙржирзНржЯ":
        await my_account(update, context)
    elif text == "ЁЯТ░ ржЙржЗржержбрзНрж░":
        await start_withdraw_request(update, context)
        return WITHDRAW_AMOUNT
    elif text == "ЁЯОБ рж░рзЗржлрж╛рж░ ржХрзЛржб":
        await get_referral_code(update, context)
    elif text == "тЬЕ Active Sessions":
        await list_active_sessions(update, context)
    
    elif user_id in ALL_ADMIN_IDS:
        if text == "ЁЯСБя╕П ржЗржЙржЬрж╛рж░ рж▓рж┐рж╕рзНржЯ":
            await list_all_users(update, context, page=0)
        elif text == "ЁЯз╛ ржЙржЗржержбрзНрж░ рж░рж┐ржХрзБрзЯрзЗрж╕рзНржЯ":
            await check_withdrawal_requests(update, context, page=0)
        elif text == "ЁЯФБ рж╕рзЗрж╢ржи ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ":
            await admin_session_management(update, context, page=0)
        elif text == "ЁЯФФ ржмрзНрж░ржбржХрж╛рж╕рзНржЯ":
            if user_id == SUPER_ADMIN_ID:
                await update.message.reply_text("ржЖржкржирж┐ рж╕ржХрж▓ ржЗржЙржЬрж╛рж░ржХрзЗ ржпрзЗ ржмрж╛рж░рзНрждрж╛ ржкрж╛ржарж╛рждрзЗ ржЪрж╛ржи, рж╕рзЗржЯрж┐ рж▓рж┐ржЦрзБржи:")
                return BROADCAST_MESSAGE
            else:
                await update.message.reply_text("тЭМ рж╢рзБржзрзБржорж╛рждрзНрж░ рж╕рзБржкрж╛рж░ ржЕрзНржпрж╛ржбржорж┐ржи ржПржЗ ржлрж┐ржЪрж╛рж░ржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗржиред")
    
    return ConversationHandler.END

# --- WhatsApp рж▓ржЧржЗржи ржлрзНрж▓рзЛ ---
async def ask_phone_number(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    phone_number = update.message.text.strip().replace(" ", "") # Remove spaces
    if not phone_number.startswith('+'):
        await update.message.reply_text("тЭМ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ рж╕ржарж┐ржХ ржХрж╛ржирзНржЯрзНрж░рж┐ ржХрзЛржбрж╕рж╣ ржиржорзНржмрж░ ржжрж┐ржи (ржпрзЗржоржи: +8801712345678):")
        return PHONE_NUMBER

    context.user_data['phone_number'] = phone_number
    
    # WhatsApp рж▓ржЧржЗржи рж╢рзБрж░рзБ ржХрж░рзБржи
    qr_url, status = await initiate_whatsapp_login(phone_number)
    
    if status == "authenticated":
        await update.message.reply_text(f"тЬЕ ржПржЗ ржиржорзНржмрж░ `{phone_number}` ржЗрждрж┐ржоржзрзНржпрзЗржЗ рж▓ржЧржЗржи ржХрж░рж╛ ржЖржЫрзЗред")
        return ConversationHandler.END
    elif qr_url and qr_url.startswith('data:image/png;base64,'):
        # Decode base64 QR data and send as photo
        qr_data = base64.b64decode(qr_url.split(',')[1])
        photo_bytes = io.BytesIO(qr_data)
        
        await update.message.reply_photo(
            photo=photo_bytes,
            caption="ржирж┐ржЪрзЗрж░ QR ржХрзЛржбржЯрж┐ рж╕рзНржХрзНржпрж╛ржи ржХрж░рзЗ WhatsApp ржП рж▓ржЧржЗржи ржХрж░рзБржиред рж╕рзНржХрзНржпрж╛ржи рж╣рзЯрзЗ ржЧрзЗрж▓рзЗ /confirm ржХржорж╛ржирзНржб ржжрж┐ржиред"
        )
        return WAIT_FOR_QR_CONFIRMATION
    else:
        await update.message.reply_text("тЭМ WhatsApp рж▓ржЧржЗржи рж╢рзБрж░рзБ ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗ ржЕржержмрж╛ ржиржорзНржмрж░ржЯрж┐ ржнрзБрж▓ред ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред")
        return ConversationHandler.END

async def confirm_login(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    phone_number = context.user_data.get('phone_number')
    if not phone_number:
        await update.message.reply_text("тЪая╕П ржХрзЛржирзЛ ржлрзЛржи ржиржорзНржмрж░ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред ржжрзЯрж╛ ржХрж░рзЗ ржЖржмрж╛рж░ рж╢рзБрж░рзБ ржХрж░рзБржиред")
        return ConversationHandler.END
    
    # рж▓ржЧржЗржи рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕ ржЪрзЗржХ ржХрж░рзБржи
    status = await check_whatsapp_login_status(phone_number)
    
    if status == "authenticated":
        # рж╕рзЗрж╢ржи ржбрзЗржЯрж╛ржмрзЗржЬрзЗ рж╕рзЗржн ржХрж░рзБржи (ржпржжрж┐ ржирж╛ ржерж╛ржХрзЗ)
        conn = sqlite3.connect("bot_database.db")
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM sessions WHERE user_id = ? AND phone_number = ?", 
                       (update.effective_user.id, phone_number))
        session_exists = cursor.fetchone()
        
        if not session_exists:
            cursor.execute(
                "INSERT INTO sessions (user_id, phone_number, session_data) VALUES (?, ?, ?)",
                (update.effective_user.id, phone_number, 'Baileys Managed')
            )
            # ржкрзЯрзЗржирзНржЯ ржпрзЛржЧ ржХрж░рзБржи
            cursor.execute(
                "UPDATE users SET points = points + ?, successful_sessions = successful_sessions + 1 WHERE user_id = ?",
                (POINTS_PER_LOGIN, update.effective_user.id)
            )
            conn.commit()
            await update.message.reply_text("тЬЕ WhatsApp рж╕ржлрж▓ржнрж╛ржмрзЗ рж▓ржЧржЗржи рж╣рзЯрзЗржЫрзЗ! ржЖржкржирж╛рж░ рж╕рзЗрж╢ржи рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржПржмржВ ржЖржкржирж┐ ржкрзЯрзЗржирзНржЯ ржкрзЗрзЯрзЗржЫрзЗржиред")
        else:
            await update.message.reply_text("тЬЕ WhatsApp рж╕ржлрж▓ржнрж╛ржмрзЗ рж▓ржЧржЗржи рж╣рзЯрзЗржЫрзЗ ржПржмржВ рж╕рзЗрж╢ржиржЯрж┐ ржЗрждрж┐ржоржзрзНржпрзЗржЗ рж░рзЗржХрж░рзНржб ржХрж░рж╛ ржЖржЫрзЗред")
        
        conn.close()
        
    elif status == "pending_qr":
        await update.message.reply_text("тМЫ WhatsApp рж▓ржЧржЗржи ржПржЦржиржУ ржкрзЗржирзНржбрж┐ржВ ржЖржЫрзЗред QR ржХрзЛржб рж╕рзНржХрзНржпрж╛ржи ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзБржи ржПржмржВ ржХрж┐ржЫрзБржХрзНрж╖ржг ржкрж░ ржЖржмрж╛рж░ /confirm ржжрж┐ржиред")
        return WAIT_FOR_QR_CONFIRMATION # Stay in this state
    else:
        # ржмрзНржпрж░рзНрже рж▓ржЧржЗржи
        conn = sqlite3.connect("bot_database.db")
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE users SET failed_sessions = failed_sessions + 1 WHERE user_id = ?",
            (update.effective_user.id,)
        )
        conn.commit()
        conn.close()
        await update.message.reply_text("тЭМ WhatsApp рж▓ржЧржЗржи ржмрзНржпрж░рзНрже рж╣рзЯрзЗржЫрзЗ ржмрж╛ рж╕рзЗрж╢ржи ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред")
    
    context.user_data.pop('phone_number', None) # Clear user data
    return ConversationHandler.END

# --- Account Management ---
async def my_account(update, context):
    user_id = update.effective_user.id
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT points, successful_sessions, failed_sessions, referral_code FROM users WHERE user_id = ?", (user_id,))
    user_data = cursor.fetchone()
    cursor.execute("SELECT COUNT(*) FROM sessions WHERE user_id = ? AND status = 'active'", (user_id,))
    session_count = cursor.fetchone()[0]
    conn.close()
    
    if user_data:
        text = (
            f"ЁЯУК **ржЖржкржирж╛рж░ ржПржХрж╛ржЙржирзНржЯрзЗрж░ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд** ЁЯУК\n\n"
            f"ЁЯТ░ **ржкрзЯрзЗржирзНржЯ ржмрзНржпрж╛рж▓рзЗржирзНрж╕:** `{user_data[0]}`\n"
            f"ЁЯФЧ **рж╕ржХрзНрж░рж┐рзЯ рж╕рзЗрж╢ржи:** `{session_count}` ржЯрж┐\n"
            f"тЬЕ **рж╕ржлрж▓ рж╕рзЗрж╢ржи:** `{user_data[1]}` ржмрж╛рж░\n" # Renamed from successful_otp
            f"тЭМ **ржмрзНржпрж░рзНрже рж╕рзЗрж╢ржи:** `{user_data[2]}` ржмрж╛рж░\n\n" # Renamed from failed_otp
            f"ЁЯОБ **ржЖржкржирж╛рж░ рж░рзЗржлрж╛рж░ ржХрзЛржб:**\n`{user_data[3]}`"
        )
        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

async def get_referral_code(update, context):
    user_id = update.effective_user.id
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT referral_code FROM users WHERE user_id = ?", (user_id,))
    referral_code = cursor.fetchone()[0]
    conn.close()
    
    await update.message.reply_text(
        f"ЁЯОБ ржЖржкржирж╛рж░ рж░рзЗржлрж╛рж░рзЗрж▓ ржХрзЛржб:\n\n"
        f"`{referral_code}`\n\n"
        f"ржПржЗ ржХрзЛржбржЯрж┐ рж╢рзЗрзЯрж╛рж░ ржХрж░рзБржи ржПржмржВ ржирждрзБржи ржЗржЙржЬрж╛рж░ рж░рзЗржЬрж┐рж╕рзНржЯрзНрж░рзЗрж╢ржирзЗрж░ рж╕ржорзЯ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред ржкрзНрж░рждрж┐ржЯрж┐ рж╕ржлрж▓ рж░рзЗржлрж╛рж░рзЗрж▓рзЗрж░ ржЬржирзНржп ржЖржкржирж┐ {POINTS_PER_REFERRAL} ржкрзЯрзЗржирзНржЯ ржкрж╛ржмрзЗржиред",
        parse_mode=ParseMode.MARKDOWN
    )

# --- Withdrawal System ---
async def start_withdraw_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT points FROM users WHERE user_id = ?", (user_id,))
    user_points = cursor.fetchone()[0]
    conn.close()
    
    available_bdt = user_points / POINTS_TO_BDT_RATE
    await update.message.reply_text(
        f"ЁЯТ░ ржЖржкржирж╛рж░ ржмрзНржпрж╛рж▓рзЗржирзНрж╕: {user_points} ржкрзЯрзЗржирзНржЯ ({available_bdt:.2f} BDT)\n\n"
        f"ржЙржЗржержбрзНрж░ ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ {MIN_WITHDRAWAL_BDT} BDT ржПрж░ рж╕ржорж╛ржи ржмрж╛ ржмрзЗрж╢рж┐ ржкрзЯрзЗржирзНржЯ ржерж╛ржХрждрзЗ рж╣ржмрзЗред\n"
        "ржЙржЗржержбрзНрж░ ржХрж░рж╛рж░ ржкрж░рж┐ржорж╛ржг рж▓рж┐ржЦрзБржи (BDT рждрзЗ):"
    )
    return WITHDRAW_AMOUNT

async def ask_withdraw_number(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        amount_bdt = float(update.message.text)
        if amount_bdt < MIN_WITHDRAWAL_BDT:
            await update.message.reply_text(
                f"тЭМ ржирзВржирзНржпрждржо ржЙржЗржержбрзНрж░ ржкрж░рж┐ржорж╛ржг: {MIN_WITHDRAWAL_BDT} BDT\n"
                "ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи:"
            )
            return WITHDRAW_AMOUNT
        
        # ржкрзЯрзЗржирзНржЯ ржЪрзЗржХ ржХрж░рзБржи
        user_id = update.effective_user.id
        required_points = amount_bdt * POINTS_TO_BDT_RATE
        
        conn = sqlite3.connect("bot_database.db")
        cursor = conn.cursor()
        cursor.execute("SELECT points FROM users WHERE user_id = ?", (user_id,))
        user_points = cursor.fetchone()[0]
        
        if user_points < required_points:
            await update.message.reply_text(
                f"тЭМ ржЖржкржирж╛рж░ ржХрж╛ржЫрзЗ ржкрж░рзНржпрж╛ржкрзНржд ржкрзЯрзЗржирзНржЯ ржирзЗржЗ!\n"
                f"ржкрзНрж░рзЯрзЛржЬржи: {required_points} ржкрзЯрзЗржирзНржЯ, ржЖржкржирж╛рж░ ржЖржЫрзЗ: {user_points} ржкрзЯрзЗржирзНржЯ\n"
                "ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи:"
            )
            return WITHDRAW_AMOUNT
        
        context.user_data['withdraw_amount'] = amount_bdt
        context.user_data['required_points'] = required_points
        
        await update.message.reply_text("ЁЯУ▒ ржЯрж╛ржХрж╛ ржЧрзНрж░рж╣ржг ржХрж░рж╛рж░ ржЬржирзНржп ржЖржкржирж╛рж░ ржмрж┐ржХрж╛рж╢/ржиржЧржж/рж░ржХрзЗржЯ ржиржорзНржмрж░ржЯрж┐ ржжрж┐ржи:")
        return WITHDRAW_NUMBER
    except ValueError:
        await update.message.reply_text("тЭМ ржнрзБрж▓ ржЗржиржкрзБржЯ! рж╢рзБржзрзБржорж╛рждрзНрж░ рж╕ржВржЦрзНржпрж╛ рж▓рж┐ржЦрзБржиред\nржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи:")
        return WITHDRAW_AMOUNT

async def process_withdraw_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    payment_number = update.message.text
    amount_bdt = context.user_data['withdraw_amount']
    required_points = context.user_data['required_points']
    user_id = update.effective_user.id
    
    # ржбрж╛ржЯрж╛ржмрзЗржЬрзЗ рж░рж┐ржХрзЛрзЯрзЗрж╕рзНржЯ рж╕рзЗржн ржХрж░рзБржи
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    
    # ржЙржЗржержбрзНрж░ рж░рж┐ржХрзЛрзЯрзЗрж╕рзНржЯ ржпрзЛржЧ ржХрж░рзБржи
    cursor.execute(
        "INSERT INTO withdrawals (user_id, amount_bdt, points_used, payment_number) VALUES (?, ?, ?, ?)",
        (user_id, amount_bdt, required_points, payment_number)
    )
    
    # ржкрзЯрзЗржирзНржЯ ржХрзЗржЯрзЗ ржирж┐ржи
    cursor.execute(
        "UPDATE users SET points = points - ? WHERE user_id = ?",
        (required_points, user_id)
    )
    
    conn.commit()
    conn.close()
    
    await update.message.reply_text(
        "тЬЕ ржЖржкржирж╛рж░ ржЙржЗржержбрзНрж░ рж░рж┐ржХрзЛрзЯрзЗрж╕рзНржЯ ржЧрзГрж╣рзАржд рж╣рзЯрзЗржЫрзЗ!\n"
        "ржЕрзНржпрж╛ржбржорж┐ржирзЗрж░ ржЕржирзБржорзЛржжржирзЗрж░ ржкрж░ рзирзк ржШржгрзНржЯрж╛рж░ ржоржзрзНржпрзЗ ржЯрж╛ржХрж╛ ржкрзЗрзЯрзЗ ржпрж╛ржмрзЗржиред"
    )
    
    # ржЕрзНржпрж╛ржбржорж┐ржиржжрзЗрж░ ржирзЛржЯрж┐ржлрж╛ржЗ ржХрж░рзБржи
    for admin_id in ALL_ADMIN_IDS:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=f"тЪая╕П ржирждрзБржи ржЙржЗржержбрзНрж░ рж░рж┐ржХрзЛрзЯрзЗрж╕рзНржЯ!\n"
                     f"ржЗржЙржЬрж╛рж░: {update.effective_user.username or update.effective_user.id}\n"
                     f"ржкрж░рж┐ржорж╛ржг: {amount_bdt} BDT\n"
                     f"ржиржорзНржмрж░: {payment_number}"
            )
        except Exception:
            logger.warning(f"Admin {admin_id} ржХрзЗ ржирзЛржЯрж┐ржлрж╛ржЗ ржХрж░рждрзЗ ржмрзНржпрж░рзНрже")
    
    return ConversationHandler.END

# --- Active Sessions ---
async def list_active_sessions(update, context):
    user_id = update.effective_user.id
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT phone_number, created_at FROM sessions WHERE user_id = ? AND status = 'active'", (user_id,))
    sessions = cursor.fetchall()
    conn.close()
    
    if not sessions:
        await update.message.reply_text("ржЖржкржирж╛рж░ ржХрзЛржирзЛ рж╕ржХрзНрж░рж┐рзЯ рж╕рзЗрж╢ржи ржирзЗржЗред")
        return
    
    text = "ЁЯУ▒ **ржЖржкржирж╛рж░ рж╕ржХрзНрж░рж┐рзЯ рж╕рзЗрж╢ржирж╕ржорзВрж╣:**\n\n"
    for i, session in enumerate(sessions, 1):
        status = await check_whatsapp_login_status(session[0])
        text += f"{i}. `{session[0]}` - {session[1]} (рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕: {status})\n"
    
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

# --- Admin Features ---
async def list_all_users(update, context, page=0):
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT user_id, username, points FROM users")
    users = cursor.fetchall()
    conn.close()

    if not users:
        await update.message.reply_text("ржХрзЛржирзЛ ржЗржЙржЬрж╛рж░ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред")
        return

    user_list = [(f"{user[1]} (ID: {user[0]}, Points: {user[2]})", user[0]) for user in users]
    
    reply_markup = build_paginated_menu(user_list, "admin_users_page", page)
    message = update.message if hasattr(update, 'message') else update.callback_query.message
    await message.reply_text(f"ЁЯСе **ржЗржЙржЬрж╛рж░ рж▓рж┐рж╕рзНржЯ (ржкрзЗржЬ {page+1})**", reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

async def check_withdrawal_requests(update, context, page=0):
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT request_id, user_id, amount_bdt, payment_number FROM withdrawals WHERE status = 'pending'")
    requests = cursor.fetchall()
    conn.close()

    if not requests:
        message = update.message if hasattr(update, 'message') else update.callback_query.message
        await message.reply_text("тЬЕ ржХрзЛржирзЛ ржкрзЗржирзНржбрж┐ржВ ржЙржЗржержбрзНрж░ рж░рж┐ржХрзБрзЯрзЗрж╕рзНржЯ ржирзЗржЗред")
        return

    for req in requests:
        text = (f"ЁЯЖФ рж░рж┐ржХрзБрзЯрзЗрж╕рзНржЯ ID: `{req[0]}`\n"
                f"ЁЯСд ржЗржЙржЬрж╛рж░ ID: `{req[1]}`\n"
                f"ЁЯТ░ ржкрж░рж┐ржорж╛ржг: `{req[2]}` BDT\n"
                f"ЁЯУ▒ ржиржорзНржмрж░: `{req[3]}`")
        keyboard = [[
            InlineKeyboardButton("тЬЕ Approve", callback_data=f"approve_{req[0]}"),
            InlineKeyboardButton("тЭМ Decline", callback_data=f"decline_{req[0]}")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        message = update.message if hasattr(update, 'message') else update.callback_query.message
        await message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

async def handle_withdrawal(query, context, request_id, status):
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    
    # рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕ ржЖржкржбрзЗржЯ ржХрж░рзБржи
    cursor.execute(
        "UPDATE withdrawals SET status = ? WHERE request_id = ?",
        (status, request_id)
    )
    
    if status == 'approved':
        # ржЗржЙржЬрж╛рж░ржХрзЗ ржирзЛржЯрж┐ржлрж╛ржЗ ржХрж░рзБржи
        cursor.execute("SELECT user_id, amount_bdt FROM withdrawals WHERE request_id = ?", (request_id,))
        result = cursor.fetchone()
        user_id, amount = result[0], result[1]
        
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text=f"тЬЕ ржЖржкржирж╛рж░ `{amount}` BDT ржПрж░ ржЙржЗржержбрзНрж░ рж░рж┐ржХрзБрзЯрзЗрж╕рзНржЯ ржЕржирзБржорзЛржжрж┐ржд рж╣рзЯрзЗржЫрзЗ!\n"
                     "рзирзк ржШржгрзНржЯрж╛рж░ ржоржзрзНржпрзЗ ржЯрж╛ржХрж╛ ржкрзЗрзЯрзЗ ржпрж╛ржмрзЗржиред"
            )
        except Exception as e:
            logger.error(f"User {user_id} ржХрзЗ ржирзЛржЯрж┐ржлрж╛ржЗ ржХрж░рждрзЗ ржмрзНржпрж░рзНрже: {e}")
    else: # declined
         # Optionally refund points if declined
        cursor.execute("SELECT user_id, points_used FROM withdrawals WHERE request_id = ?", (request_id,))
        result = cursor.fetchone()
        user_id, points_used = result[0], result[1]
        cursor.execute("UPDATE users SET points = points + ? WHERE user_id = ?", (points_used, user_id))
        
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text=f"тЭМ ржЖржкржирж╛рж░ `{amount}` BDT ржПрж░ ржЙржЗржержбрзНрж░ рж░рж┐ржХрзБрзЯрзЗрж╕рзНржЯ ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред ржмрзНржпржмрж╣рзГржд ржкрзЯрзЗржирзНржЯ (`{points_used}`) ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржлрзЗрж░ржд ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗред"
            )
        except Exception as e:
            logger.error(f"User {user_id} ржХрзЗ ржирзЛржЯрж┐ржлрж╛ржЗ ржХрж░рждрзЗ ржмрзНржпрж░рзНрже: {e}")

    conn.commit()
    conn.close()
    
    await query.message.edit_text(f"тЬЕ рж░рж┐ржХрзБрзЯрзЗрж╕рзНржЯ `{request_id}` рж╕ржлрж▓ржнрж╛ржмрзЗ `{status}` ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ!", parse_mode=ParseMode.MARKDOWN)


async def admin_session_management(update, context, page=0):
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    # Fetch all distinct phone numbers associated with user sessions
    cursor.execute("SELECT DISTINCT phone_number, user_id FROM sessions")
    sessions_db = cursor.fetchall()
    conn.close()

    if not sessions_db:
        message = update.message if hasattr(update, 'message') else update.callback_query.message
        await message.reply_text("ржХрзЛржирзЛ рж╕рзЗржн ржХрж░рж╛ рж╕рзЗрж╢ржи ржирзЗржЗред")
        return

    # For display, get associated username
    session_list = []
    for phone, user_id in sessions_db:
        conn = sqlite3.connect("bot_database.db")
        cursor = conn.cursor()
        cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
        username = cursor.fetchone()
        conn.close()
        username_display = username[0] if username else f"User {user_id}"
        session_list.append((f"{phone} ({username_display})", phone))
    
    reply_markup = build_paginated_menu(session_list, "admin_session_page", page)
    message = update.message if hasattr(update, 'message') else update.callback_query.message
    await message.reply_text(f"ЁЯФБ **рж╕рзЗрж╢ржи ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ (ржкрзЗржЬ {page+1})**\n\nрж╕рзЗрж╢ржи ржЕрзНржпрж╛ржХрж╢ржирзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ ржиржорзНржмрж░ ржмрзЗржЫрзЗ ржирж┐ржи:", reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    return ADMIN_SESSION_ACTION

async def admin_select_session_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    phone_number = context.user_data.get('admin_selected_phone') # This will be set by the button_handler
    if not phone_number:
        await query.message.reply_text("тЪая╕П ржХрзЛржирзЛ ржлрзЛржи ржиржорзНржмрж░ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рж╛ рж╣рзЯржирж┐ред ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред")
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("ЁЯУК рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕ ржЪрзЗржХ", callback_data=f"admin_session_status_{phone_number}")],
        [InlineKeyboardButton("тЭМ рж▓ржЧржЖржЙржЯ", callback_data=f"admin_session_logout_{phone_number}")],
        [InlineKeyboardButton("тЖйя╕П ржорзЗржирзБрждрзЗ ржлрж┐рж░рзЗ ржпрж╛ржи", callback_data="admin_session_cancel")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        f"ржЖржкржирж┐ `{phone_number}` ржиржорзНржмрж░ржЯрж┐ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзЗржЫрзЗржиред ржХрж┐ ржХрж░рждрзЗ ржЪрж╛ржи?",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN
    )
    return ADMIN_SESSION_ACTION # Stay in this state to handle further actions

async def admin_perform_session_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    data = query.data.split('_')
    action = data[2] # e.g., 'status' or 'logout'
    phone_number = data[3]

    if action == "status":
        status = await check_whatsapp_login_status(phone_number)
        await query.edit_message_text(f"`{phone_number}` ржиржорзНржмрж░рзЗрж░ рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕: `{status}`", parse_mode=ParseMode.MARKDOWN)
    elif action == "logout":
        success = await terminate_whatsapp_session(phone_number)
        if success:
            conn = sqlite3.connect("bot_database.db")
            cursor = conn.cursor()
            cursor.execute("UPDATE sessions SET status = 'inactive' WHERE phone_number = ?", (phone_number,))
            conn.commit()
            conn.close()
            await query.edit_message_text(f"тЬЕ `{phone_number}` рж╕рзЗрж╢ржиржЯрж┐ рж╕ржлрж▓ржнрж╛ржмрзЗ рж▓ржЧржЖржЙржЯ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред", parse_mode=ParseMode.MARKDOWN)
        else:
            await query.edit_message_text(f"тЭМ `{phone_number}` рж╕рзЗрж╢ржиржЯрж┐ рж▓ржЧржЖржЙржЯ ржХрж░рждрзЗ ржмрзНржпрж░рзНржеред", parse_mode=ParseMode.MARKDOWN)
    
    # After action, return to main menu or session management
    reply_markup = get_main_keyboard(update.effective_user.id)
    await context.bot.send_message(update.effective_chat.id, "ржЕржкрж╛рж░рзЗрж╢ржи рж╕ржорзНржкржирзНржиред", reply_markup=reply_markup)
    context.user_data.pop('admin_selected_phone', None)
    return ConversationHandler.END

async def broadcast_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message.text
    conn = sqlite3.connect("bot_database.db")
    cursor = conn.cursor()
    cursor.execute("SELECT user_id FROM users")
    user_ids = [row[0] for row in cursor.fetchall()]
    conn.close()
    
    success = 0
    failed = 0
    
    for user_id in user_ids:
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success += 1
        except Exception:
            failed += 1
    
    await update.message.reply_text(
        f"тЬЕ ржмрзНрж░ржбржХрж╛рж╕рзНржЯ рж╕ржорзНржкржирзНржи!\n\n"
        f"рж╕ржлрж▓: {success} ржЗржЙржЬрж╛рж░\n"
        f"ржмрзНржпрж░рзНрже: {failed} ржЗржЙржЬрж╛рж░"
    )
    return ConversationHandler.END

# --- Utility Functions ---
def build_paginated_menu(items, prefix, page):
    start_idx = page * ITEMS_PER_PAGE
    end_idx = start_idx + ITEMS_PER_PAGE
    buttons = []
    
    for item_display, item_value in items[start_idx:end_idx]:
        buttons.append([InlineKeyboardButton(item_display, callback_data=f"{prefix}_select_{item_value}")])
    
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("тЧАя╕П ржЖржЧрзЗрж░ ржкрзЗржЬ", callback_data=f"{prefix}_page_{page-1}"))
    if end_idx < len(items):
        nav_buttons.append(InlineKeyboardButton("ржкрж░рзЗрж░ ржкрзЗржЬ тЦ╢я╕П", callback_data=f"{prefix}_page_{page+1}"))
    
    if nav_buttons:
        buttons.append(nav_buttons)
        
    return InlineKeyboardMarkup(buttons)

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("ржЕржкрж╛рж░рзЗрж╢ржи ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред", reply_markup=get_main_keyboard(update.effective_user.id))
    return ConversationHandler.END

# --- Button Handlers ---
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data.split('_')
    
    prefix = data[0] + "_" + data[1] if len(data) > 1 and data[1] in ["users", "session"] else data[0]

    if prefix == "admin_users_page": # Pagination for user list
        page = int(data[3])
        await list_all_users(query, context, page)
    elif prefix == "admin_session_page": # Pagination for session list
        if data[2] == "page":
            page = int(data[3])
            await admin_session_management(query, context, page)
        elif data[2] == "select":
            phone_number = data[3]
            context.user_data['admin_selected_phone'] = phone_number
            await admin_select_session_action(update, context) # Pass update to new handler
            return ADMIN_SESSION_ACTION
    elif prefix == "approve":
        request_id = int(data[1])
        await handle_withdrawal(query, context, request_id, 'approved')
    elif prefix == "decline":
        request_id = int(data[1])
        await handle_withdrawal(query, context, request_id, 'declined')
    elif prefix == "admin_session_status" or prefix == "admin_session_logout":
        await admin_perform_session_action(update, context) # Handle status/logout actions
        return ConversationHandler.END # End the conversation after action
    elif query.data == "admin_session_cancel":
        await query.message.edit_text("рж╕рзЗрж╢ржи ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред")
        await context.bot.send_message(query.message.chat_id, "ржкрзНрж░ржзрж╛ржи ржорзЗржирзБ:", reply_markup=get_main_keyboard(update.effective_user.id))
        return ConversationHandler.END

def main() -> None:
    setup_database()
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Conversation Handlers
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            PHONE_NUMBER: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_phone_number)],
            WAIT_FOR_QR_CONFIRMATION: [CommandHandler("confirm", confirm_login)],
            WITHDRAW_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_withdraw_number)],
            WITHDRAW_NUMBER: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_withdraw_request)],
            BROADCAST_MESSAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_message)],
            ADMIN_SESSION_ACTION: [CallbackQueryHandler(button_handler)], # Handle actions within this state
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    
    # Add handlers
    application.add_handler(conv_handler)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, main_menu_handler))
    application.add_handler(CallbackQueryHandler(button_handler)) # General button handler for non-conversation states

    logger.info("ржмржЯ рж╕ржлрж▓ржнрж╛ржмрзЗ ржЪрж╛рж▓рзБ рж╣рзЯрзЗржЫрзЗ...")
    application.run_polling()

if __name__ == "__main__":
    main()
